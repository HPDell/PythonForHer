{
  "hash": "aed88545898d059c8f361a975a254e98",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"程序流程控制\"\ndescription: \"条件语句、循环语句和推导式\"\n---\n\n# 条件语句\n\n如果程序需要根据一定条件执行不同的操作，就需要使用条件语句\n\n## 格式\n\n:::: {.columns}\n::: {.column width=\"33%\"}\n```python\nif condition1:\n    expression1\nelse\n    expression0\n```\n:::\n::: {.column width=\"33%\"}\n```python\nif condition1:\n    expression1\nelif condition2:\n    expression2\nelif condition2:\n    expression2\nelse\n    expression0\n```\n:::\n::: {.column width=\"33%\"}\n```python\nif condition1:\n    expression1\n    if condition2:\n        expression2\n    else condition3:\n        expression3\nelse\n    expression0\n```\n:::\n::::\n\n- `condition` 条件表达式的结果必须是 `bool` 类型\n- `elif` 可以有任意多个，也可以是 0 个\n- `if-else` 结构可以嵌套\n- **注意保持缩进**\n\n---\n\n### 案例：根据房龄进行分类标记\n\n> 根据二手房的建成年份判断是不是 10 年以上的老房子。\n如果是，标记为 `\"aged10\"`；如果不是，标记为 `\"new\"`。\n\n::: {#7abbec33 .cell execution_count=1}\n``` {.python .cell-code}\ndef is_old_property(built_year, current_year=2024):\n    if (current_year - built_year) > 10:\n        return \"aged10\"\n    else:\n        return \"new\"\n\nis_old_property(2010)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'aged10'\n```\n:::\n:::\n\n\n---\n\n> 根据二手房的建成年份进行房龄分级。\n如果是 20 年以上，标记为 `\"aged20\"`；\n如果是 10 年以上，标记为 `\"aged10\"`；\n如果 10 年以下，标记为 `\"new\"`。\n\n. . .\n\n::: {#26e29b4d .cell execution_count=2}\n``` {.python .cell-code}\ndef proeprty_age_label(built_year, current_year=2024):\n    if (current_year - built_year) > 20:\n        return \"aged20\"\n    elif (current_year - built_year) > 10:\n        return \"aged10\"\n    else:\n        return \"new\"\n\nprint(proeprty_age_label(2000))\nprint(proeprty_age_label(2010))\nprint(proeprty_age_label(2020))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\naged20\naged10\nnew\n```\n:::\n:::\n\n\n---\n\n### 案例：校验数据\n\n> 上次我们定义了一个函数，根据二手房总数和每页显示的数量计算总页数。\n> \n> ```python\n> def page_num(page_size, total):\n>     return total // page_size + int(total % page_size > 0)\n> ```\n> \n> 但是有一个隐藏条件： `page_size` 的值不能是 0，而且一般也不能超过 20。\n> 修改这个函数，当条件不满足时，返回 0 。\n\n::: {.callout-tip}\n- 这里需要用到条件运算符 `and or` 等。\n- \n:::\n\n---\n\n::: {#97908f16 .cell execution_count=3}\n``` {.python .cell-code}\ndef page_num(page_size, total):\n    if page_size > 0 and page_size <= 20:\n        return total // page_size + int(total % page_size > 0)\n    else:\n        return 0\n\nprint(page_num(0, 100))\nprint(page_num(1000, 845))\nprint(page_num(20, 845))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n0\n43\n```\n:::\n:::\n\n\n::: {.callout-note}\n这里事实上使用 `0` 作为一种错误代码。\n一般情况下，`page_num` 为 0 ，表示没有页，属于一种错误情况。\n这种情况下，我们就可以停止爬虫。\n:::\n\n## 缩进\n\nPython 中通过缩进区分不同层级的代码。\n\n- `:` 后就表示开始一个新的层级\n- 缩进可以使用空格（Space）或者制表符（Tab）\n\n:::: {.columns}\n::: {.column}\n\n![](./assets/python-space-indent.png)\n\n:::\n::: {.column}\n\n![](./assets/python-tab-indent.png)\n\n:::\n::::\n\n## 短路判断\n\n当 `if` 语句中的条件由很多部分组成时，Python 一般从左到右逐个判断。\n但是当某一个语句的结果判断完成后，如果后面的判断无法改变这个结果，Python 就不再继续判断了。\n\n- 当多个判断由 `or` 连接，其中一个是 `True` 时，触发短路，结果是 `True`\n- 当多个判断由 `and` 连接，其中一个是 `False` 时，触发短路，结果是 `False`\n\n这个特性可以保证可读性和正确性。\n\n---\n\n### 案例：空字符串\n\n> 通常情况下，如果一个变量的值可以是 `None`，那么我们称这个变量是可空变量。\n> 但是对于字符串，不一定只有值是 `None` 的字符串才是空字符串。\n> 值是 `\"\"` 的字符串实际上也是空字符串。\n> 写一个函数，判断一个字符串实际上是不是“空”字符串。\n\n::: {#e79ae9e0 .cell execution_count=4}\n``` {.python .cell-code}\ndef is_null_str(value):\n    if (value is None) or (len(value) == 0):\n        return True\n    else:\n        return False\n\nprint(is_null_str(None))\nprint(is_null_str(\"\"))\nprint(is_null_str(\"abc\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nFalse\n```\n:::\n:::\n\n\n---\n\n### 案例：非空字符串\n\n> 同样的问题，但是写一个函数判断是不是非空字符串。\n\n::: {#b6f4da62 .cell execution_count=5}\n``` {.python .cell-code}\ndef not_null_str(value):\n    if (value is not None) and (len(value) > 0):\n        return True\n    else:\n        return False\n\nprint(not_null_str(None))\nprint(not_null_str(\"\"))\nprint(not_null_str(\"abc\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nFalse\nTrue\n```\n:::\n:::\n\n\n# 循环语句\n\n如果要对一组变量执行同样的操作，可以使用循环语句。\n循环语句有两种，`for` 循环和 `while` 循环。\n\n## For 循环\n\nFor 循环又称“迭代”，是最常用的一种循环。\n\n```python\nfor item in iterable:\n    # 对 item 执行一些操作\n```\n\n::: {.callout-important}\n\n- `item` 是循环变量，依次从 `iterable` 中取一个值。\n- 放在 `iterable` 位置上的一定是可以迭代的。\n  - 一般 `list` `dict` `set` `tuple` 都是可以迭代的。\n  - 函数 `range` 的返回值也是可以迭代的\n  - `enumerate` `zip` 的返回值也是可以迭代的\n:::\n\n---\n\n### 案例：批量房龄分级\n\n> 现在有一批房子的建成年份，根据这些年份进行分级。\n\n::: {#8908758f .cell execution_count=6}\n``` {.python .cell-code}\nprop_years = [1998, 2005, 2007, 2012, 2016, 2019]\n```\n:::\n\n\n::: {#f70f735c .cell execution_count=7}\n``` {.python .cell-code}\nfor item in prop_years:\n    print(proeprty_age_label(item))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\naged20\naged10\naged10\naged10\nnew\nnew\n```\n:::\n:::\n\n\n---\n\n### 案例：查找因数\n\n> 写一个函数，输出一个整数除了1和它本身以外的所有因数。\n\n::: {#e2b3c555 .cell execution_count=8}\n``` {.python .cell-code}\ndef fractions(value):\n    for i in range(2, value):\n        if value % i == 0:\n            print(i)\n\nfractions(24)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\n4\n6\n8\n12\n```\n:::\n:::\n\n\n::: {#7eb79a76 .cell execution_count=9}\n``` {.python .cell-code}\nfractions(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n5\n```\n:::\n:::\n\n\n## While 循环\n\n当循环范围无法确定，只能确定循环执行的条件，使用 `while` 循环。\n\n```python\nwhile (condition):\n    operations\n```\n\n- 当 `condition` 是 `True` 时，执行 `operations` 的操作；\n- 每次执行完 `operations` 的操作，检查 `condition` 是否还满足；\n  - 如果 `condition` 仍然满足，再次执行 `operations` 的操作，然后再检查；\n  - 一旦 `condition` 不满足了，就不再执行 `operations` 的操作。\n\n---\n\n### 案例：阶乘\n\n> 计算一个正整数的阶乘。\n\n::: {#ec2ba3df .cell execution_count=10}\n``` {.python .cell-code}\ndef factorial(x):\n    result = 1\n    while x > 0:\n        result = x * result\n        x = x - 1\n    return result\n\nfactorial(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n120\n```\n:::\n:::\n\n\n::: {.callout-note}\n- 避免了递归函数，提高了计算性能。\n- 更便于读懂程序。\n:::\n\n---\n\n### 案例：级数\n\n> 计算几何级数 $y = \\sum_{i=0}^\\infty \\frac{1}{2^i}$ 的数值，精度为 $1 \\times 10^{-6}$。\n> 也就是说，当计算结果的变化不超过 $1 \\times 10^{-6}$ 时，停止计算。\n\n::: {#c31d648d .cell execution_count=11}\n``` {.python .cell-code}\ndef geometric_progression(base=2, eps=1e-6):\n    result0 = 0\n    result = 1\n    power = 0\n    while (result - result0) > eps:\n        result0 = result\n        power = power + 1\n        result = result + 1.0 / (base ** power)\n    return result\n\ngeometric_progression()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n1.9999990463256836\n```\n:::\n:::\n\n\n## 循环嵌套\n\n循环里面也可以写循环，但是要注意循环变量不要重复。\n这种循环被称为多重循环。\n\n```python\nfor i in range(0, 10):\n    for j in range(0, 10):\n        print((i, j))\n```\n\n多重循环有的时候不得不用，但是尽量减少使用。\n\n- Python 的效率并不是很高，循环嵌套层数太多影响效率。\n- 循环层数越多，代码越难以维护和分析。\n\n---\n\n### 案例：查找质数\n\n> 给定一个最大值，查找不大于该最大值的自然数中的质数。\n\n:::: {.columns}\n::: {.column}\n\n::: {#dc668972 .cell execution_count=12}\n``` {.python .cell-code}\ndef prime_number(upper):\n    if upper <= 1:\n        return []\n    elif upper == 2:\n        return [2]\n    primes = []\n    for i in range(2, upper + 1):\n        has_factor = False\n        for j in range(2, i):\n            if i % j == 0:\n                has_factor = True\n        if not has_factor:\n            primes = primes + [i]\n    return primes\n```\n:::\n\n\n:::\n::: {.column}\n\n::: {#950db9b3 .cell execution_count=13}\n``` {.python .cell-code}\nprime_number(20)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[2, 3, 5, 7, 11, 13, 17, 19]\n```\n:::\n:::\n\n\n::: {#041b42d8 .cell execution_count=14}\n``` {.python .cell-code}\nprime_number(50)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n```\n:::\n:::\n\n\n::: {.callout-warning}\n当输入值越来越大时，得到结果的过程也会越来越慢。\n:::\n\n:::\n::::\n\n## 中断和继续\n\n在循环中，使用 `break` `continue` 两个关键词可以主动控制循环的走向。\n\n- `break` 使循环立刻终止，不再执行循环体内后面的语句，直接回到循环体外。\n- `continue` 跳过这一次循环中后面的语句，直接进入下一次循环。\n\n通常和判断语句一起使用。\n\n---\n\n### 案例：有限制的级数计算\n\n> 计算之前那个几何级数，\n> 但是要求迭代次数不超过 10 次，如果超过了，就直接返回当前的结果。\n\n::: {#b2185865 .cell execution_count=15}\n``` {.python .cell-code}\ndef geometric_progression2(base=2, eps=1e-6, max_iter=10):\n    result0 = 0\n    result = 1\n    power = 0\n    it = 0\n    while (result - result0) > eps:\n        result0 = result\n        power = power + 1\n        result = result + 1.0 / (base ** power)\n        if it >= 10:\n            break\n    return result\n\ngeometric_progression2()\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n1.9999990463256836\n```\n:::\n:::\n\n\n---\n\n### 案例：处理二手房均价\n\n> 房地产交易平台上，通常只有别墅的房价是以总价的形式显示的，其他都是按单位面积均价显示。\n> 编写一个函数，将所有价格统一处理成单位面积均价的形式。\n> 房地产信息由字典给出。\n\n::: {#674682de .cell execution_count=16}\n``` {.python .cell-code}\ndef process_price(property_list):\n    for item in property_list:\n        if item['type'] != '别墅':\n            continue\n        item['price'] = item['price'] / item['size']\n```\n:::\n\n\n::: {.callout-important}\n- `continue` 并不是总是非常必要，通过调整判断条件大多数情况下都可以避免。\n- 一般只有当处理非常复杂、代码嵌套层级很多时，在处理开始前使用 `continue`，可以减少嵌套层级。\n:::\n\n# 推导式\n\n## 列表推导式\n\n与循环语句类似，由一个叫“**列表推导式**”的语法，可以从一个列表得到另一个列表。\n也可以设置一些条件。\n\n```python\n[opeartion(x) for x in iterable]\n[opeartion(x) for x in iterable if condition]\n```\n\n上面的例子可以直接使用列表推导式\n\n::: {#27e5d17f .cell execution_count=17}\n``` {.python .cell-code}\n[proeprty_age_label(item) for item in prop_years]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n['aged20', 'aged10', 'aged10', 'aged10', 'new', 'new']\n```\n:::\n:::\n\n\n::: {.callout-important}\n列表推导式非常重要！\n:::\n\n---\n\n### 优势\n\n- 这种处理称为“向量化处理”，相比于循环语句，效率更高。\n- 对于简单的处理，列表推导式更易读。\n- 不仅可以做一维循环，也可以做多维循环。\n\n### 劣势\n\n- 多维循环时不易理解和阅读。\n- 执行处理复杂时代码会比较长，不便于调试。\n\n---\n\n### 案例：根据坐标生成唯一标识\n\n> 现在有一组坐标，精确到小数点后 6 位，按照之前的方法转换成唯一标识。\n\n::: {#29110f7d .cell execution_count=18}\n``` {.python .cell-code}\ncoords = [(112.2452, 20.45456), (112.456127, 20.145678), (112.976825, 30.142501)]\n```\n:::\n\n\n:::{.fragment}\n\n::: {#01b5258b .cell execution_count=19}\n``` {.python .cell-code}\n[f\"{round(c[0], 6)}-{round(c[1], 6)}\" for c in coords]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n['112.2452-20.45456', '112.456127-20.145678', '112.976825-30.142501']\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n我们也可以将循环变量直接展开为两个元素，这种语法被称为“解包”。\n\n::: {#ea7baf25 .cell execution_count=20}\n``` {.python .cell-code}\n[f\"{round(lon, 6)}-{round(lat, 6)}\" for lon, lat in coords]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n['112.2452-20.45456', '112.456127-20.145678', '112.976825-30.142501']\n```\n:::\n:::\n\n\n:::\n\n---\n\n### 案例：向量内积\n\n> 给两个向量（默认为列向量），计算内积 $\\mathbf{x}^\\mathrm{T} \\mathbf{y}$。\n> 如果 $\\mathbf{x}=(x_1,x_2,\\cdots,x_n)$， $\\mathbf{y}=(y_1,y_2,\\cdots,y_n)$，\n> 那么 $\\mathbf{x}^\\mathrm{T} \\mathbf{y} = \\sum_{i=1}^n x_i y_i$。\n\n::: {#9db9b440 .cell execution_count=21}\n``` {.python .cell-code}\nx = [1,2,3]\ny = [4,5,6]\n```\n:::\n\n\n::: {.callout-tip}\n- 使用 `zip` 可以将两个列表并列。\n:::\n\n::: {.fragment}\n\n::: {#e5226fec .cell execution_count=22}\n``` {.python .cell-code}\nsum([xi * yi for xi, yi in zip(x, y)])\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n32\n```\n:::\n:::\n\n\n:::\n\n---\n\n### 案例：莱布尼兹级数计算圆周率\n\n> 莱布尼兹级数 $1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} + \\cdots = \\frac{\\pi}{4}$ 。\n> 只计算前 100 项的和并乘以 4。\n\n::: {.fragment}\n\n::: {#84003a25 .cell execution_count=23}\n``` {.python .cell-code}\n(1 + sum([((-1) ** i) / (2 * i + 1) for i in range(1, 100)])) * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n3.131592903558553\n```\n:::\n:::\n\n\n:::\n\n---\n\n### 案例：计算向量累积和\n\n> 假设一个向量有 $n$ 个元素，计算从第一个元素开始到每个元素位置的累积和。\n> 比如，$[1,2,3]$ 的累积和是 $[1,3,6]$。\n\n::: {.callout-tip}\n- 解包时可以使用 `_` 表示不需要的元素。\n- `enumerate` 可以获取元素的序号。\n:::\n\n::: {.fragment}\n\n::: {#827d062d .cell execution_count=24}\n``` {.python .cell-code}\ndef accumulate(vec):\n    return [sum(vec[0:(i+1)]) for i, _ in enumerate(vec)]\n\naccumulate([1,2,3])\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n[1, 3, 6]\n```\n:::\n:::\n\n\n:::\n\n## 字典推导式\n\n类似于列表推导式，字典推导式如下\n\n```python\n{key_operation(x): value_operation(x) for x in iterable}\n{key_operation(x): value_operation(x) for x in iterable if condition}\n```\n\n需要注意的是：\n\n- 不论是 `key_operation` 还是 `value_operation` 都可以和 `x` 无关\n- `key_operation(x)` 的结果必须是一种“可哈希”的类型，包括 `int` `float` `str` `bool` `tuple` 以及其他所有具有自定义哈希方法的类型。\n\n::: aside\n哈希的具体原理暂时不用深究，记住这几个类型即可。\n:::\n\n---\n\n### 案例：元组列表转字典\n\n> 现在有一组元组构成的列表，元组有三个元素，分别表示小区名、小区均价和物业费。\n> 为了便于读取，将元组列表转换成字典，以小区名为键，值是字典 `{'avg_price': price, 'management': fee}`\n\n::: {#7868d264 .cell execution_count=25}\n``` {.python .cell-code}\ncommunities = [('A', 1.2, 1.2), ('b', 2.3, 1.3)]\n```\n:::\n\n\n::: {.fragment}\n\n::: {#fe03d1d2 .cell execution_count=26}\n``` {.python .cell-code}\n{x[0]: {'avg_price': x[1], 'management': x[2]} for x in communities}\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n{'A': {'avg_price': 1.2, 'management': 1.2},\n 'b': {'avg_price': 2.3, 'management': 1.3}}\n```\n:::\n:::\n\n\n:::\n\n---\n\n### 案例：字符串列表记录长度\n\n> 将字符串列表转换为字典，键是字符串，值是长度。\n\n::: {#197c3912 .cell execution_count=27}\n``` {.python .cell-code}\ntokens = [\n    'abcdefg',\n    '1927h3ksmfd',\n    '19lpwwodksj'\n]\n{i: len(i) for i in tokens}\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n{'abcdefg': 7, '1927h3ksmfd': 11, '19lpwwodksj': 11}\n```\n:::\n:::\n\n\n::: {.callout-tip title=\"聚合查询\"}\n实际中，我们会对数据进行分组，然后计算这个组的某个指标，比如数量、平均数等。\n\n- 每个小区里面有多少二手房\n- 每个省的基尼系数\n:::\n\n## 其他推导式\n\n### 集合推导式\n\n```python\n{opeartion(x) for x in iterable}\n{opeartion(x) for x in iterable if condition}\n```\n\n重复元素会自动被去除。\n\n### 元组推导式\n\n```python\n(opeartion(x) for x in iterable)\n(opeartion(x) for x in iterable if condition)\n```\n\n元组推导式的结果并不是一个元组，而是一个类似于 `range` 的生成器，并不会立刻求值。\n\n# 下节\n\n自定义类\n\n- 成员和方法\n- 构造函数\n- 属性\n- 静态函数\n\n",
    "supporting": [
      "02-process-control_files"
    ],
    "filters": [],
    "includes": {}
  }
}