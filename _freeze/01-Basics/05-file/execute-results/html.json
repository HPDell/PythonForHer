{
  "hash": "62285d5ff11bfb6ec98b0d871d166d1d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"文件\"\ndescription: \"Python 中对文件处理的方法\"\n---\n\n# 文件\n\n理论上讲，文件是对任何读写设备的抽象。\n读写设备有很多，主要就是硬盘和网卡。\n\n## 文件类型\n\n说到类型，主要指的是两种：二进制文件和文本文件。\n\n- 二进制文件：由二进制数据构成的文件，比如图片、程序、压缩包等。通常是难以阅读的，需要一定的程序进行读取。\n- 文本文件：由字符构成的文件，只要使用文本编辑器打开就可以直接阅读。\n  - 字符包括可见字符和不可见字符，回车、换行、制表都是不可见字符。字母、数字和特殊符号都是可见字符。\n  - 所有字符（包括中文）都是由一定的二进制码记录的，这种字符与二进制的对应方式称为“编码”。常见的编码方式有 ASCII、UTF-8、GB2312 等。\n\n## 文件格式\n\n不论是二进制文件还是文本文件，都有一定的格式。通常情况下，文件名的最后一个 `.` 后面的字符表示其格式，这部分被称为“扩展名”。\n\n- 二进制文件：JPEG、ZIP、EXE 等。二进制数据按照一定方式排列，才能正确执行。\n- 文本文件：\n  - TXT：纯文本文件，没有什么固定的格式，只表示一些文本。\n  - CSV：逗号分隔值，每行表示一个数据，每个数据由很多字段组成，字段之间由逗号分隔。\n  - JSON：一般用于表示字典数据。\n\n---\n\n::: {.callout-important title=\"文件格式和扩展名并不是一回事\"}\n- 文件格式是数据组织的方式，通常由一定的标准指定。而文件扩展名只是文件名的一部分，用来表示文件格式。\n- 通常情况下扩展名和格式要一一对应，文件才能被正确读取。但是如果扩展名不对，只要格式是正确的，也可以用相应的程序打开。比如把图片的扩展名改成 `.txt` 一样可以用 PS 打开。\n- 扩展名可以任意修改，格式并不会随之变化，修改格式必须要通过一定的程序进行转换。\n比如可以将 JSON 文件的扩展名写成 `.txt` 并不会影响文件的格式；\nJPG 图片的后缀修改成 `.ai` 并不代表它就变成了 Adobe Illustrator 文件。\n- 一个文件格式也可有多个扩展名表示，比如 JPEG 图片的扩展名可以是 `.jpg` `.jpeg`。\n- 也可以根据自己的需要设定一些格式，但通常情况下用已经定义好的格式比较方便。\n:::\n\n## 文件读写\n\n几乎任何文件读写操作都要遵循以下几个步骤：\n\n- 打开文件：这个过程是获取文件的读写权，只有拥有读写权时才能读取文件。\n  - 每个文件的读写权在同一时间只能有一个程序拥有。\n  - 读写权有三种，读、写和追加，分别用 `r` `w` `a` 表示。\n- 操作文件：根据申请的读写权对文件进行操作。\n- 关闭文件：这一步非常重要。只有关闭了文件之后文件才能被其他程序使用，否则其他程序只有等当前程序退出了。通常操作完文件后直接关闭文件。\n\n# 纯文本文件\n\n## 打开并读取\n\nPython 中自带纯文本文件的读写函数 `open()` ，用于打开文件。\n\n```python\nfile = open(\"./assets/demo.txt\")\nfile.close()\n```\n\n然而，这样就需要手动关闭文件。所以通常不这样做，而是使用 `with` 关键字让 Python 自动关闭。\n\n::: {#5260d02a .cell execution_count=1}\n``` {.python .cell-code}\nwith open(\"./assets/demo.txt\") as file:\n    for row in file:\n        print(row.strip())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntitle,year\n与凤行,2024\n风吹半夏,2022\n谁是凶手,2021\n楚乔传,2017\n花千骨,2015\n```\n:::\n:::\n\n\n## 写入文件\n\n`print` 就可以用来写入文件，参数 `file` 就可以指定输出位置。如果不指定，就是标准输出，一般情况下是控制台。\n\n::: {#781afa29 .cell execution_count=2}\n``` {.python .cell-code}\nwith open(\"./assets/out.txt\", mode=\"w\") as fout:\n    print(\"赵丽颖参演过的电视剧：\\n\", file=fout)\n    with open(\"./assets/demo.txt\") as fin:\n        for i, row in enumerate(fin):\n            if i == 0:\n                continue\n            title, year = row.strip().split(\",\")\n            print(f\"- 《{title}》（{year}年）\", file=fout)\n```\n:::\n\n\n生成的文件如下：\n\n::: {#8a0e42e1 .cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\n赵丽颖参演过的电视剧：\n\n- 《与凤行》（2024年）\n- 《风吹半夏》（2022年）\n- 《谁是凶手》（2021年）\n- 《楚乔传》（2017年）\n- 《花千骨》（2015年）\n```\n:::\n:::\n\n\n# CSV 格式\n\n## 文件格式\n\n其实上述文件就已经是逗号分隔值文件，只是我们是按照纯文本文件的方式读取的。\nPython 提供了一个读写 CSV 文件的包 `csv`。\n\n::: {.callout-note title=\"CSV 文件格式\"}\nCSV 格式没有明文规定的规范，但是有一定的通用规范。大致上：\n\n- 第一行是表头，用逗号分割每个列名（也称字段名）\n- 后续每行代表一条记录，各个列的属性以逗号分隔，与列名对应\n- 如果某个字段包含 `,` （分隔符），字段值用 `\"\"` 包裹\n:::\n\n包 `csv` 提供了两种读取数据的方法，一种将每行解析为列表，另一种将每行解析为字典。\n\n## 文件读取\n\n不论是哪种读取方法，都需要打开文件并创建一个“读取器”。\n\n::: {#1aef82fd .cell execution_count=4}\n``` {.python .cell-code}\nimport csv\nwith open(\"./assets/demo.txt\", newline='') as fin:\n    reader = csv.reader(fin)\n    for row in reader:\n        print(f\"- 《{row[0]}》（{row[1]}年）\")\nwith open(\"./assets/demo.txt\", newline='') as fin:\n    reader = csv.DictReader(fin)\n    for row in reader:\n        print(\"* 《{title}》（{year}年）\".format_map(row))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n- 《title》（year年）\n- 《与凤行》（2024年）\n- 《风吹半夏》（2022年）\n- 《谁是凶手》（2021年）\n- 《楚乔传》（2017年）\n- 《花千骨》（2015年）\n* 《与凤行》（2024年）\n* 《风吹半夏》（2022年）\n* 《谁是凶手》（2021年）\n* 《楚乔传》（2017年）\n* 《花千骨》（2015年）\n```\n:::\n:::\n\n\n## 文件写入\n\n写文件的方法也是类似的，需要创建一个写入器。这里就以字典式为例。\n\n::: {#18c8bb7f .cell execution_count=5}\n``` {.python .cell-code}\ndemo_data = {\n    \"title\": [\"与凤行\", \"风吹半夏\"],\n    \"year\": [2024, 2022]\n}\n```\n:::\n\n\n::: {#33c24028 .cell execution_count=6}\n``` {.python .cell-code}\nimport csv\nwith open(\"./assets/demo_dict_writer_out.csv\", mode=\"w\", newline=\"\") as fout:\n    writer = csv.DictWriter(fout, demo_data.keys())\n    writer.writeheader()\n    for row in zip(*demo_data.values()):\n        writer.writerow({\n            \"title\": row[0],\n            \"year\": row[1]\n        })\n```\n:::\n\n\n## 读写器的选择\n\n- 如果文件描述的对象类似于字典，那么字典式读写器更方便。类似于字典的对象的特点是不同字段之间性质差别很大，但字段本身一一对应。\n- 如果文件没有表头，而且自定义表头是可行的，那字典式读写器还是要更方便一些。\n- 如果文件描述的不同对象有不同的字段，那么字典式读写器已经不再适用了。\n- 如果文件描述的对象本身就类似于列表，比如一个时间序列或矩阵，那么列表式读写器更方便。\n\n## 更高级的工具：Pandas\n\nPython 自带的 csv 包只提供了比较基础的操作 CSV 文件的功能，主要是文本处理的功能。\n但是第三方的 Pandas 包提供了更强大的功能，包括解析、筛选、变换、聚合等。\n\n::: {.columns}\n::: {.column width=\"52%\"}\n\n::: {#76337b1c .cell execution_count=7}\n``` {.python .cell-code}\nimport pandas as pd\nd = pd.read_csv(\"./assets/demo.txt\")\nd.head(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>title</th>\n      <th>year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>与凤行</td>\n      <td>2024</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>风吹半夏</td>\n      <td>2022</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#48cc7522 .cell execution_count=8}\n``` {.python .cell-code}\nd['year'].min()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n2015\n```\n:::\n:::\n\n\n:::\n::: {.column width=\"48%\"}\n\n::: {#9a825aed .cell execution_count=9}\n``` {.python .cell-code}\nd['actor'] = \"赵丽颖\"\nd.head(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>title</th>\n      <th>year</th>\n      <th>actor</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>与凤行</td>\n      <td>2024</td>\n      <td>赵丽颖</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>风吹半夏</td>\n      <td>2022</td>\n      <td>赵丽颖</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#9b3e7eb5 .cell execution_count=10}\n``` {.python .cell-code}\nd.count()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\ntitle    5\nyear     5\nactor    5\ndtype: int64\n```\n:::\n:::\n\n\n:::\n::: \n\n# JSON 格式\n\n## 文件格式\n\nJSON 全称是“JavaScript 对象表示法”，但往往与 Python 原生类型对应（虽然不是一一对应）。\n\n```json\n{\n    \"actor\": \"赵丽颖\",\n    \"tv\": [\n        {\"title\": \"与凤行\", \"year\": 2024, \"collabrators\": [\"林更新\"]},\n        {\"title\": \"风吹半夏\", \"year\": 2022, \"collabrators\": [\"欧豪\", \"李光洁\"]},\n        {\"title\": \"谁是凶手\", \"year\": 2021, \"collabrators\": [\"肖央\", \"董子健\"]},\n        {\"title\": \"楚乔传\", \"year\": 2017, \"collabrators\": [\"林更新\"]},\n        {\"title\": \"花千骨\", \"year\": 2015, \"collabrators\": [\"霍建华\"]}\n    ]\n}\n```\n\nJSON 格式在网页和网络请求中的使用非常普遍，几乎所有现代网络编程接口（API）都是以 JSON 格式传递数据的。\n因此该格式非常重要。\n\n## 读取和解析\n\n在 CSV 文件和纯文本文件中，我们主要使用的是读取器，通过不断读取文件内容执行操作。\n但 JSON 格式的文件通常不是一行一行地读取的，而是整个进行解析的。\n因此，需要首先读取文件全部内容，再按照 JSON 格式解析。\n可见，我们主要需要使用 JSON 解析器（Parser），而至于解析的对象是文件还是字符串就不是很重要了。\n\n反之也一样，通常 CSV 文件是一行一行写入的，但 JSON 文件需要整个写入，否则格式就出错了。\n因此需要生成全部文件内容，再全部写到文件中，这里需要的就是 JSON 格式字符串的“生成器”，也叫“序列化器”（Serializer）。\n\nPython 提供了包 `json` 用于解析和生成 JSON 字符日，但提供了直接操作文件的功能。\n\n## 解析\n\n使用 `load()` 函数直接解析 JSON 文件。\n\n::: {#8e5c88aa .cell execution_count=11}\n``` {.python .cell-code}\nimport json\nwith open(\"./assets/demo_json.json\") as fin:\n    data = json.load(fin)\n    print(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'actor': '赵丽颖', 'tv': [{'title': '与凤行', 'year': 2024, 'collabrators': ['林更新']}, {'title': '风吹半夏', 'year': 2022, 'collabrators': ['欧豪', '李光洁']}, {'title': '谁是凶手', 'year': 2021, 'collabrators': ['肖央', '董子健']}, {'title': '楚乔传', 'year': 2017, 'collabrators': ['林更新']}, {'title': '花千骨', 'year': 2015, 'collabrators': ['霍建华']}]}\n```\n:::\n:::\n\n\n也可以先读取文件为字符串再使用 `loads()` 解析。\n\n::: {#c06131d9 .cell execution_count=12}\n``` {.python .cell-code}\nfrom pathlib import Path\njson.loads(Path(\"./assets/demo_json.json\").read_text())\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n{'actor': '赵丽颖',\n 'tv': [{'title': '与凤行', 'year': 2024, 'collabrators': ['林更新']},\n  {'title': '风吹半夏', 'year': 2022, 'collabrators': ['欧豪', '李光洁']},\n  {'title': '谁是凶手', 'year': 2021, 'collabrators': ['肖央', '董子健']},\n  {'title': '楚乔传', 'year': 2017, 'collabrators': ['林更新']},\n  {'title': '花千骨', 'year': 2015, 'collabrators': ['霍建华']}]}\n```\n:::\n:::\n\n\n## 生成\n\n`dump()` 和 `dumps()` 分别用于生成 JSON 文件和字符串。\n\n::: {#78b5007f .cell execution_count=13}\n``` {.python .cell-code}\njson.dumps(demo_data, ensure_ascii=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n'{\"title\": [\"与凤行\", \"风吹半夏\"], \"year\": [2024, 2022]}'\n```\n:::\n:::\n\n\n::: {#efd35a3d .cell execution_count=14}\n``` {.python .cell-code}\nwith open(\"./assets/demo_json_out.json\", mode=\"w\") as fout:\n    json.dump(demo_data, fout, ensure_ascii=False)\n```\n:::\n\n\n也可以生成具有一定缩进格式的字符串\n\n::: {#e8fc46ce .cell execution_count=15}\n``` {.python .cell-code}\nprint(json.dumps(demo_data, ensure_ascii=False, indent=4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"title\": [\n        \"与凤行\",\n        \"风吹半夏\"\n    ],\n    \"year\": [\n        2024,\n        2022\n    ]\n}\n```\n:::\n:::\n\n\n# 下节\n\n网络\n\n- 请求、响应\n- 头、体\n- 数据和 Cookie\n\n",
    "supporting": [
      "05-file_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}