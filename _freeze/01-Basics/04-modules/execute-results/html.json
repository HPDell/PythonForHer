{
  "hash": "5a4a478fa580f520836c3a953daf1360",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"模块和包\"\ndescription: \"打包的一组类、函数和变量\"\n---\n\n# 模块\n\n一个 Python 文件就是一个模块，这个模块可以由其他文件导入，并在其他 Python 文件中使用。\n\n## 模块示例\n\n创建一个 `list_prcess.py` 文件，内容如下\n\n```python\ndef page_num(page_size, total):\n    return total // page_size + int(total % page_size > 0)\n\ndef offset(page_size, page):\n    return page_size * (page - 1)\n\ndef coords_id(loc):\n    return f\"{round(loc[0], 6)}-{round(loc[1], 6)}\"\n```\n\n不仅可以放函数，也可以放类。\n通过这种方式拆分代码，可以更好地组织代码。\n\n## 导入模块\n\n在其他文件中，通过下面的语句导入这个模块。有几种导入方式\n\n```python\nimport list_process                 # 使用时用包名做前缀\nimport list_process as lp           # 使用时以 lp 别名做前缀\nfrom list_process import *          # 导入所有函数，直接使用函数名\nfrom list_process import page_num   # 只能使用导入的函数，不能使用其他的\n```\n\n区别只在于函数调用地方式上\n\n::: columns\n::: column\n\n::: {#ecaf0a22 .cell execution_count=1}\n``` {.python .cell-code}\nimport list_process\nlist_process.page_num(10, 210)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n21\n```\n:::\n:::\n\n\n::: {#0152a938 .cell execution_count=2}\n``` {.python .cell-code}\nimport list_process as lp\nlp.page_num(10, 210)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n21\n```\n:::\n:::\n\n\n:::\n\n::: column\n\n::: {#b9638224 .cell execution_count=3}\n``` {.python .cell-code}\nfrom list_process import *\npage_num(10, 210)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n21\n```\n:::\n:::\n\n\n::: {#53c40836 .cell execution_count=4}\n``` {.python .cell-code}\nfrom list_process import page_num\npage_num(10, 210)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n21\n```\n:::\n:::\n\n\n:::\n:::\n\n## 符号 `__name__`\n\n::: {.callout-note title=\"模块化带来的一个问题\"}\n导入模块时，该模块的所有代码都会被执行。\n所以通常模块中只声明函数和类，不会调用函数和类。\n这有时候会造成一定的问题：如果我们既想将函数作为模块提供给其他代码，又想直接使用 `python` 执行这个文件，并调用函数呢？\n:::\n\n可以通过变量 `__name__` 来区分该模块执行的方式。如果 `__name__ == \"__main__\"`，那么表示现在是直接使用 `python` 去执行，而不是作为模块导入。\n\n```python\ndef page_num(page_size, total):\n    return total // page_size + int(total % page_size > 0)\n\nif __name__ == \"__main__\":\n    print(page_num(10, 210))\n```\n\n# 包\n\n一组具有一定文件结构模块构成了一个包。\n\n## 内置包\n\n绝大多数情况下我们都是使用 Python 提供的包。\n内置包有很多，比较常用的有\n\n- `csv` `json` `yaml` `toml` `pickle` 等读写文件的包\n- `os` `sys` `pathlib` 等与系统交互的包\n- `datetime` `time` 操作日期时间的包\n- `math` 进行数学运算\n- `logging` 输出日志\n- `dataclasses` 数据类\n- `re` 正则表达式\n\n## 第三方包\n\nPython 的强大之处就在于有浩如烟海的第三方包，例如\n\n- `numpy` `pandas` `geopandas` 等做矩阵运算和数据处理\n- `urllib` `requests` 等发送网络请求、处理数据的包\n- `tqdm` 显示进度条\n\n可以在 [https://pypi.org/](https://pypi.org/) 网站上搜索包。\n\n## 依赖项\n\n每个 Python 包和模块可能都需要使用一些其他的包，这些其他的包就被称为当前包的“依赖项”。\n根据约定，`requirements.txt` 文件列出了包的依赖项及其版本号。\n\n```\ndjango==3.2.12\npsycopg2>=2.9.3\nPillow>=9.0.1\nsorl-thumbnail>=12.8.0\n```\n\n::: {.callout-tip}\n版本号也可以不指定。但通常要指定，避免版本不同的包提供的函数和类不同，导致当前包无法工作。\n:::\n\n## 包管理器\n\n由于每个包都可能有很多依赖项，一个一个手动安装显然是不现实的。\n`pip` 命令行程序是 Python 的包管理器，用来自动处理和安装包及其依赖项。\n但 `pip` 不是 Python 代码，因此不能在 Python 代码中使用，只能在终端命令行中使用。\n\n```powershell\npip install urllib3 pandas  # 安装包\npip uninstall pandas        # 卸载包\n```\n\n但在 Windows 上，有些包的安装可能会遇到问题。还有一些其他的包管理器可以使用，比如 Anaconda 、 Mamba 等。\n\n```powershell\nconda install pandas urllib3\nconda remove pandas\n```\n\n# 下节\n\n文件和文件系统\n\n- 文件格式\n- 文件操作\n\n",
    "supporting": [
      "04-modules_files"
    ],
    "filters": [],
    "includes": {}
  }
}