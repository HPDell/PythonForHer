---
title: "网络"
description: "与外部世界交互"
format:
  revealjs: 
    theme: [dark, url-styles.scss]
execute: 
  cache: true
---

# 网络基础

互联网定义了很多协议，用于计算机之间进行通信。
为了在通信过程中传输数据，又定义了一些格式。

## 超文本传输协议（HTTP）

互联网中最常见的信息交互协议是 HTTP，后来为了增加安全性，在 HTTP 协议基础上出现了 HTTPS 协议。
浏览器主要处理的就是 HTTP 协议传输的数据，按下 `F12` 打开开发者工具就可以看到就网络传输的过程。

:::: {.columns}
::: {.column}
![](./assets/WebPage.png)
:::
::: {.column}
![](./assets/DeveloperTools.png)
:::
::::

---

### 请求和响应

HTTP 协议的工作方式是请求和响应。

::: {.columns}
::: {.column}

#### 请求 (Request)

计算机向服务器发送 HTTP 请求，并提供给服务器一些数据。

#### 响应 (Response)

服务器根据请求内容，给计算机发送相应的数据。

:::
::: {.column}

```{mermaid}
%%| echo: false
sequenceDiagram
    participant 计算机
    participant 服务器
    计算机 ->> 服务器: 请求1
    服务器 ->> 计算机: 响应1
    计算机 ->> 服务器: 请求2
    服务器 ->> 计算机: 响应2
```

:::
:::

但本质上，请求和响应都是按照一定格式发送的数据。
只要我们按照这种格式发送数据，就可以实现交互。

## 统一资源路径（URL）

互联网上的资源非常多，计算机是怎么知道要向哪里发送请求呢？
通常使用的是 URL ，俗称地址。

### 常用格式

::: {.url}
<span class="p">协议</span>://<span class="d">域名</span>/<span class="l">路径</span>?<span class="q">查询字符串</span>

<span class="p">https</span>://<span class="d">zz.esf.fang.com</span>/<span class="l">chushou/3_183860422.htm</span>?<span class="q">channel=2,2&psid=1_1_60</span>
<span class="p">https</span>://<span class="d">restapi.amap.com</span>/<span class="l">v3/place/text</span>?<span class="q">city=zhengzhou&offset=20&page=1</span>
:::

只要按照上述方式拼接字符串，就是一个合法的 URL 。

---

### 路径

URL 中使用 `/` 作为路径的分割符。
这里的路径与文件系统中的路径的含义可能是相同的，也能是不同的，存在某种特殊的映射关系。

::: {.callout-note title="静态页面"}
静态页面是在服务器上固定的文件，URL 后面通常以 `.html` `.htm` 等结尾。
服务器根据路径直接发送文件内容，过程类似于下载。
静态页面的路径一般情况下与文件系统一一对应，而且也不支持查询字符串。

例如 `http://gwmodel.whu.edu.cn/` 都是静态页面。
:::

::: {.callout-note title="动态页面"}
服务器根据路径或模板临时渲染一个页面，URL 通常没有固定类似于扩展名的结尾，或者以 `.jsp` `.php` 等结尾。
通常支持查询字符串。
:::

---

### 查询字符串

如果把路径比作函数，那么查询字符串就类似于参数。
服务器会根据查询字符串返回相应的页面。

::: {.url}
?[[name1]{.k}=[value1]{.v}&[name2]{.k}=[value2]{.v}]{.q}
:::

::: {.callout-important}
- 查询字符串以 `?` 开始，否则被视为是路径。
- 每个参数的键值对依次排列，用 `&` 连接。
- 参数名和参数值之间用 `=` 连接。
- 参数可以没有值，但是必须有名。
:::

---

### 域名

域名部分完整的格式其实是 `用户名:密码@域名:端口` ，
但这四个部分除了域名以外都是可以省略的，所以通常情况下只需要写域名即可。

::: {.callout-important}
- 如果不写端口，那么表示端口值是默认端口，HTTP 协议的默认端口是 80，HTTPS 协议的默认端口是 443。
  但如果网站服务并不是发布在 80 端口上，就必须要写出端口。
  比如 [https://blog.huyg.site:8443/](https://blog.huyg.site:8443/)
- 如果不写用户名，就不用写密码，表示以匿名用户登录。如果写了用户名，也可以不写密码，表示无需密码。
- 这种用户名密码的身份验证方式比较危险，很容易泄露，所以现在大多数网站已经抛弃了这种认证方式。
:::

## 请求数据

除了在 URL 里面提供参数，请求也可以发送一些数据，但这些数据要按照一定的格式转换为字符串，也就是“序列化”。
常用的格式有：

- `form-data` ：表单格式，最早的发送请求数据的方式，通常用于页面表单。可以用来传文件。
- `json` ：常用于网络接口，用于在发送一些特别复杂的数据。
- `xml` ：通常也用于网络接口，有一些比较复杂的网络服务需要以这种方式提供数据。

除了这些格式以外，每个服务都可以以自己的方式处理数据，所以需要研究页面，对症下药。

## 请求方式

发送请求时，除了要指定请求地址，还要指定请求方式（Method）。
常用的请求方式有

- `GET`: 通常表示“仅获取”。是一般 HTTP 请求最常用的方式。在 REST 接口中表示“查询”。
- `POST`: 通常表示“提交”，提交表单数据时常用这个方式。在 REST 接口中表示“添加”数据。
- `PUT`: 常用于 REST 格式的网络接口中，用于表示“修改”数据。
- `DELETE`: 常用于 REST 格式的网络接口中，用于表示“删除”数据。

## 响应数据

### HTML 响应

最常见的响应。
可以是静态的 HTML 文档，也可以是服务器渲染出来的 HTML 格式文档。
浏览器可以根据文档内容渲染页面，这是最早的浏览器的默认工作方式。

::: {.columns}
::: {.column}
![](assets/HTMLPage.png)
:::
::: {.column}
![](assets/HTMLSource.png)
:::
:::

--- 

### 其他响应

通过开发者工具可以看到，要正常地显示一个页面，除了 HTML 响应以外，还有很多其他类型的响应。例如
样式表（CSS，用于描述页面的样式）、脚本和图片等。

随着网络技术的发展，有时一个服务可能只响应一些数据，并不提供页面。
这种相应的格式一般是 JSON 或者 XML。
目前绝大多数网站已经支持了 JSON 格式的响应，不会只提供 XML 格式的响应。

```json
{ "code":99,"msg":"您的账号信息过期，请重新登录",
  "data":null,"help":"","dom":"","infocode":99 }
```

---

下面是一个 XML 响应的例子

```xml
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>Mikan Project - 我的番组</title>
    <description>Mikan Project - 我的番组</description>
    <item>
      <guid isPermaLink="false">[银色子弹字幕组]</guid>
      <title>[银色子弹字幕组]</title>
      <description>[银色子弹字幕组][198.1MB]</description>
    </item>
  </channel>
</rss>
```

## 头和体

::: {.callout-tip title="问题"}
不论请求响应以何种格式传输数据，传过来的都是字符串，那我们如何判断传过来的是什么格式的字符串呢？
:::

事实上，一个请求或响应由两部分构成：头（Header）和体（Body）。
请求数据和响应数据指的都是“体”。
而为了辅助处理体，“头”中有很多非常重要的信息。

---

### 请求头

在开发者工具中就可以看到请求头的信息

::: {.columns}
::: {.column}

![](assets/RequestHeader.png)

:::
::: {.column}

::: {.callout-note title="一些重要的头"}

- `Content-Type`: 发送的请求数据的格式。
- `Accept`: 接受的响应内容的格式，服务器根据这个字段设置响应格式。
- `User-Agent`: 用于识别浏览器的信息。
- `Cookie`: 通常保存在浏览该域名时保存的一些数据，可以用于用户认证。
:::

:::
:::

---

### 响应头

同样在开发者工具中可以看到响应头，一些比较重要的是：

- `Status`: 极为重要！这里的代码反映了请求的状态。
  - `200`: 请求成功。
  - `404`: 找不到资源，通常是路径导致的错误。
  - `500`: 内部服务器错误，通常是请求参数或者数据错误。
- `Content-Type`: 响应体的格式。
- `Content-Encoding`: 响应体编码，通常是一些压缩数据的格式，例如 `gzip` 等，解压后可得到原始数据。

## Cookie

HTTP 协议有一大特点：“无状态”。任何两次 HTTP 请求和响应都是独立的，服务器不会保存任何与请求有关的信息。
但用户往往需要在不同页面之间跳转以完成一个工作，这种情况下就必然需要一些信息关联不同的页面。

- 用户在登录页进行登录，在其他页面访问一些个人数据。
- 用户在购物页选择要购买的商品，在购物车页面管理添加的商品，并在支付页进行支付。

Cookie 就是一种保存必要数据的方法。
每次发送请求时，Cookie 都会自动放在请求头中发送。

# 网络编程

使用 `urllib3` 库发送请求和处理响应。

## 确定 URL

只有确定了 URL ，才能使用库发送请求。
通常有两种方式：根据文档构造、从页面获取。


---

### 根据文档构造

适用于网络接口，有文档说明接口如何使用。
例如，查看“高德地图搜索 POI^[https://lbs.amap.com/api/webservice/guide/api/search]” 的接口文档


```{python}
base_url = 'https://restapi.amap.com'
query = {
  'keywords': '北京大学',
  'city': 'beijing',
  'offset': 20,
  'page': 1,
  'extensions': 'all'
}
query_string = '&'.join([f'{k}={v}' for k, v in query.items()])
f'{base_url}/v3/place/text?{query_string}'
```

---

有一个库函数可以直接实现这个过程，并且进行了额外的处理。


```{python}
from urllib.parse import urlencode
query_string = urlencode(query)
print(f'{base_url}/v3/place/text?{query_string}')
```

::: {.callout-tip title="转义字符"}
在 URL 中一些特殊字符（如 `, + |` 等）需要使用转义字符表示，避免产生冲突。
例如如果参数值有 `&` 就需要转义，否则就会被认为是一个新的参数。
而且早期 URL 仅支持 ASCII 编码，像中文这样无法用 ASCII 码表示的就只能进行转义。
:::

---

### 从页面获取

如果不是访问接口，而是直接访问页面，那么页面中就会包含很多链接。
例如下面这个网页每个房源的标题就都包含一个链接。

::: {.columns}
::: {.column width="40%"}

![](assets/FangList.png)

:::
::: {.column width="60%"}

```html
<dd>
  <h4 class="clearfix">
    <a ps="1_1_60" href="/chushou/3_183860422.htm" target="_blank" data_channel="2,2"
      title="小两口房,低价出售,好房不等人,先到先得!!">
      <span class="tit_shop"> 小两口房,低价出售,好房不等人,先到先得!!</span>
    </a>
  </h4>
  <p class="tel_shop"> 1室1厅 <i>|</i> 59.99㎡ <i>|</i>
    <a class="link_rk" href="//baike.fang.com/item/中层/12851744" target="_blank">中层</a>
    （共11层） <i>|</i> 西向 <i>|</i> 2012年建 <i>|</i>
    <span class="people_name">
      <a nofollow="" href="/agentshop/1165372.html"
        title="访问[李庆孟]的个人网上店铺，查看更多房源" target="_blank">李庆孟
      </a>
    </span>
  </p>
</dd>
```

:::
:::

## 发送请求

`urllib3` 包中的 `request` 函数负责发送请求并解析 HTTP 响应。

```{python}
#| cache: true
import urllib3
res_hp_list = urllib3.request("GET", "https://zz.esf.fang.com/")
if res_hp_list.status == 200:
  print(res_hp_list.data[:1000].decode())
```

---

### 带参数的请求

```{python}
#| cache: true
from pathlib import Path
res_hp_item = urllib3.request(
  "GET",
  "https://zz.esf.fang.com/chushou/3_183860422.htm",
  fields={'channel': '2,2', 'psid': '1_1_60'}
)
if res_hp_item.status == 200:
  print(res_hp_item.data[:1000].decode())
```

---

### 带参数的 POST 请求

如果是 POST 请求，那么查询字符串只能手动生成

```python
encoded_args = urlencode({"arg": "value"})
url = "https://httpbin.org/post?" + encoded_args
resp = urllib3.request("POST", url, fields={"field": "value"})
```

此时 `fields` 参数的值将作为 FormData 格式的请求体传输。

### 传递 JSON 数据

如果请求中需要发送 JSON 数据，使用 `json` 参数

```python
resp = urllib3.request(
    "POST",
    "https://httpbin.org/post",
    json={"attribute": "value"},
    headers={"Content-Type": "application/json"}
)
```

## 处理响应

`request()` 函数的返回值就是解析后的响应，通过检查 `status` 和 `data` 就可以获取状态码和响应数据。

### 处理状态码

```{python}
res_test_status = urllib3.request(
  "GET",
  "https://httpbin.org/post"
)
if res_test_status.status == 200:
  print("Success")
else:
  print(f"Status: {res_test_status.status}")
```

---

### 解析 JSON 响应

通常情况下，直接以字符串的方式处理响应体是非常困难的。
由于响应体大多都遵循一定的格式，所以可以将其解析为相应的类对象，则会更方便，这个过程是“反序列化”。
JSON 格式的响应体可以直接用 `.json()` 函数转换为字典对象，

```{python}
res_test_json = urllib3.request(
  "GET",
  "https://api.xygeng.cn/one"
)
if res_test_json.status == 200:
  print(res_test_json.json())
```

---

### 解析 HTML 响应

HTML 本身是一种 XML 格式的扩展，通常我们使用 `parsel` 等库进行解析，
使用 XPATH 或者 CSS Selector 提取数据。

```{python}
from parsel import Selector
if res_hp_list.status == 200:
  s = Selector(text=res_hp_list.data.decode())
  hp_list = s.xpath('//div[@class="shop_list shop_list_4"]/dl/dd/h4/a/span/text()')
  print([x.get().strip() for x in hp_list[:5]])
```

```{python}
if res_hp_list.status == 200:
  s = Selector(text=res_hp_list.data.decode())
  hp_pages = s.css('div.shop_list dl dd h4 a::attr(href)').getall()
  print(hp_pages[:5])
```

---

### 反序列化为类对象

如果返回值不是 JSON 格式而是 XML 格式，那么就不能直接转化为字典了。
有的时候字典使用起来不太方便，例如要不断地查看返回样例确定返回数据的结构以确定键名。
这时可以使用 `xsdata` 包提供的反序列化的功能将返回值直接转化为 Python 类对象。

```python
from xsdata.formats.dataclass.parsers import XmlParser
from xsdata.formats.dataclass.parsers.config import ParserConfig

@dataclass
class RSS:
    channel: RSSChannel = field(metadata={'type': 'Element'})

def feed_parse(feed: FeedSource):
    rss_res: res.HTTPResponse = http.request('GET', feed.url)
    if rss_res.status == 200:
        rss_body = ''.join([x for x in rss_res.data.decode() if x.isprintable()])
        rss = xmlparser.from_string(rss_body, RSS)
        torrent_upload_batch(rss.channel.item, feed)
```

# 案例：高德地图 POI 获取

## 高德地图 API

### 什么是 API

::: {.columns}
::: {.column}

API 的全称是“应用程序编程接口”，通常是指软件与软件之间的交互方式，通常由一个程序（调用方）通过接口调用另一个程序。
“接口”类似于一种规范，调用方只要按照这种规范使用这个接口，就能实现相应的功能，而不需要关心这个功能具体是如何实现的。

:::
::: {.column}

![](./assets/HDMI.jpg)

图为硬件接口，但与软件接口的概念类似。

:::
:::

---

### 高德开放平台

::: {.columns}
::: {.column}

大多数手机软件之所以可以工作，是因为有服务器提供了接口（也称服务），使很多操作可以通过服务器进行。
高德将高德地图所使用的一些接口开放了出来，使得其他软件也可以使用，这就是高德开放平台。

:::
::: {.column}

![](./assets/amap-lbs.png)

:::
:::

若要使用高德开放平台提供的服务，需要先进行开发者认证，并创建密钥（key）。

## 设计思路

::: {.columns}
::: {.column}

流程图可以帮助我们理清爬虫编写的思路。

- 城市和类别需要通过编码表获取
- 通过不断构造 URL 中的查询字符串就能不断获取下一页
- 总数可以通过第一页中的结果得知
- 所有数据可以保存成 CSV 文件

:::
::: {.column}

```{mermaid}
%%| echo: false
flowchart TD
  A[确定城市和类别] --> B
  B[获取第1页并提取总数] --> C
  C{是否已获取所有 POI} -->|是| D
  C -->|否| E
  D[获取下一页] --> C
  E[保存所有数据]
```

:::
:::

## 基本爬虫

### POI 分类编码和城市编码

POI 分类编码分为：大类、中类、小类。
每一级用两位数字进行编码，例如“公共停车场”的编码是 `150904`，`15` 表示“交通设施服务”，`09` 表示停车场，`04` 表示公共停车场。

::: {.callout-tip}
由于高德 POI 查询超过 100 页的时候会有问题，所以通常我们选择最相关的中类和小类，以减少该类 POI 的数量。
:::

城市可以直接使用中文或拼音，也可以使用编码，如郑州为 `410100` 。

---

### 获取一页数据


```{python}
from pathlib import Path
from urllib3 import request

MY_KEY = Path('./key_amap.txt').read_text().strip()
GET = "GET"
BASE_URL = 'https://restapi.amap.com/v3/place/text'
BASE_QS = {
  'key': MY_KEY,
  'types': '150900',
  'city': '410100',
  'citylimit': True,
  'offset': 20
}

def get_page(page):
  resp = request(GET, BASE_URL, fields={
    **BASE_QS,
    'page': page
  })
  if resp.status == 200:
    res = resp.json()
    if res['status'] == "1":
      total_count = res['count']
      pois = res['pois']
      return (int(total_count), pois)
    else:
      raise ValueError("Response status is zero", res['info'])
  else:
    raise ValueError("Request failed", resp.status)

total, pois = get_page(1)
",".join([x['name'] for x in pois[:5]])
```

---

### 整体逻辑

```{python}
import json
from time import sleep

def page_num(page_size, total):
  return total // page_size + int(total % page_size > 0)

def get_all():
  total_count, pois = get_page(1)
  pages = page_num(BASE_QS['offset'], total_count)
  for i in range(2, pages + 1):
    pois.extend(get_page(i)[1])
    sleep(0.1)
  Path("./assets/parkings.json").write_text(json.dumps(pois, ensure_ascii=False))

get_all()
```

---

### 检查数据

```{python}
poi_data = json.loads(Path("./assets/parkings.json").read_text())
for item in poi_data[:10]:
  print('{id},{name},{location}'.format_map(item))
```


## 改进爬虫

现在这个爬虫有几个问题：

- 没有进行异常处理，一旦无法正常获取数据，爬虫会终止。
- 所有数据在爬取完毕才保存，一旦中间出现异常，所有数据都会丢失（即时存档）。
- 爬虫中断后，无法回复爬虫，只能从头开始爬取（断点续爬）。
- 爬虫只适用于这一种情况，如果要换一个城市或类型，则只能修改源代码（参数化）。
- key 的调用次数有上限，无法利用多个 key 提高每日爬取量。

这些问题将在后面逐步解决。
