---
title: "网络"
description: "与外部世界交互"
format:
  revealjs: 
    theme: [dark, url-styles.scss]
            
---

# 网络基础

互联网定义了很多协议，用于计算机之间进行通信。
为了在通信过程中传输数据，又定义了一些格式。

## 超文本传输协议（HTTP）

互联网中最常见的信息交互协议是 HTTP，后来为了增加安全性，在 HTTP 协议基础上出现了 HTTPS 协议。
浏览器主要处理的就是 HTTP 协议传输的数据，按下 `F12` 打开开发者工具就可以看到就网络传输的过程。

:::: {.columns}
::: {.column}
![](./assets/WebPage.png)
:::
::: {.column}
![](./assets/DeveloperTools.png)
:::
::::

---

### 请求和响应

HTTP 协议的工作方式是请求和响应。

::: {.columns}
::: {.column}

#### 请求 (Request)

计算机向服务器发送 HTTP 请求，并提供给服务器一些数据。

#### 响应 (Response)

服务器根据请求内容，给计算机发送相应的数据。

:::
::: {.column}

```{mermaid}
%%| echo: false
sequenceDiagram
    participant 计算机
    participant 服务器
    计算机 ->> 服务器: 请求1
    服务器 ->> 计算机: 响应1
    计算机 ->> 服务器: 请求2
    服务器 ->> 计算机: 响应2
```

:::
:::

但本质上，请求和响应都是按照一定格式发送的数据。
只要我们按照这种格式发送数据，就可以实现交互。


## 统一资源路径（URL）

互联网上的资源非常多，计算机是怎么知道要向哪里发送请求呢？
通常使用的是 URL ，俗称地址。

### 常用格式

::: {.url}
<span class="p">协议</span>://<span class="d">域名</span>/<span class="l">路径</span>?<span class="q">查询字符串</span>

<span class="p">https</span>://<span class="d">zz.esf.fang.com</span>/<span class="l">chushou/3_183860422.htm</span>?<span class="q">channel=2,2&psid=1_1_60</span>
<span class="p">https</span>://<span class="d">restapi.amap.com</span>/<span class="l">v3/place/text</span>?<span class="q">city=zhengzhou&offset=20&page=1</span>
:::

只要按照上述方式拼接字符串，就是一个合法的 URL 。

---

### 路径

URL 中使用 `/` 作为路径的分割符。
这里的路径与文件系统中的路径的含义可能是相同的，也能是不同的，存在某种特殊的映射关系。

::: {.callout-note title="静态页面"}
静态页面是在服务器上固定的文件，URL 后面通常以 `.html` `.htm` 等结尾。
服务器根据路径直接发送文件内容，过程类似于下载。
静态页面的路径一般情况下与文件系统一一对应，而且也不支持查询字符串。

例如 `http://gwmodel.whu.edu.cn/` 都是静态页面。
:::

::: {.callout-note title="动态页面"}
服务器根据路径或模板临时渲染一个页面，URL 通常没有固定类似于扩展名的结尾，或者以 `.jsp` `.php` 等结尾。
通常支持查询字符串。
:::

---

### 查询字符串

如果把路径比作函数，那么查询字符串就类似于参数。
服务器会根据查询字符串返回相应的页面。

::: {.url}
?[[name1]{.k}=[value1]{.v}&[name2]{.k}=[value2]{.v}]{.q}
:::

::: {.callout-important}
- 查询字符串以 `?` 开始，否则被视为是路径。
- 每个参数的键值对依次排列，用 `&` 连接。
- 参数名和参数值之间用 `=` 连接。
- 参数可以没有值，但是必须有名。
:::

---

### 域名

域名部分完整的格式其实是 `用户名:密码@域名:端口` ，
但这四个部分除了域名以外都是可以省略的，所以通常情况下只需要写域名即可。

::: {.callout-important}
- 如果不写端口，那么表示端口值是默认端口，HTTP 协议的默认端口是 80，HTTPS 协议的默认端口是 443。
  但如果网站服务并不是发布在 80 端口上，就必须要写出端口。
  比如 [https://blog.huyg.site:8443/](https://blog.huyg.site:8443/)
- 如果不写用户名，就不用写密码，表示以匿名用户登录。如果写了用户名，也可以不写密码，表示无需密码。
- 这种用户名密码的身份验证方式比较危险，很容易泄露，所以现在大多数网站已经抛弃了这种认证方式。
:::

## 请求数据

除了在 URL 里面提供参数，请求也可以发送一些数据，但这些数据要按照一定的格式转换为字符串，也就是“序列化”。
常用的格式有：

- `form-data` ：表单格式，最早的发送请求数据的方式，通常用于页面表单。可以用来传文件。
- `json` ：常用于网络接口，用于在发送一些特别复杂的数据。
- `xml` ：通常也用于网络接口，有一些比较复杂的网络服务需要以这种方式提供数据。

除了这些格式以外，每个服务都可以以自己的方式处理数据，所以需要研究页面，对症下药。

## 响应数据

### HTML 响应

最常见的响应。
可以是静态的 HTML 文档，也可以是服务器渲染出来的 HTML 格式文档。
浏览器可以根据文档内容渲染页面，这是最早的浏览器的默认工作方式。

::: {.columns}
::: {.column}
![](assets/HTMLPage.png)
:::
::: {.column}
![](assets/HTMLSource.png)
:::
:::

--- 

### 其他响应

通过开发者工具可以看到，要正常地显示一个页面，除了 HTML 响应以外，还有很多其他类型的响应。例如
样式表（CSS，用于描述页面的样式）、脚本和图片等。

随着网络技术的发展，有时一个服务可能只响应一些数据，并不提供页面。
这种相应的格式一般是 JSON 或者 XML。
目前绝大多数网站已经支持了 JSON 格式的响应，不会只提供 XML 格式的响应。

```json
{ "code":99,"msg":"您的账号信息过期，请重新登录",
  "data":null,"help":"","dom":"","infocode":99 }
```

## 头和体

::: {.callout-tip title="问题"}
不论请求响应以何种格式传输数据，传过来的都是字符串，那我们如何判断传过来的是什么格式的字符串呢？
:::

事实上，一个请求或响应由两部分构成：头（Header）和体（Body）。
请求数据和响应数据指的都是“体”。
而为了辅助处理体，“头”中有很多非常重要的信息。

---

### 请求头

在开发者工具中就可以看到请求头的信息

::: {.columns}
::: {.column}

![](assets/RequestHeader.png)

:::
::: {.column}

::: {.callout-note title="一些重要的头"}

- `Content-Type`: 发送的请求数据的格式。
- `Accept`: 接受的响应内容的格式，服务器根据这个字段设置响应格式。
- `User-Agent`: 用于识别浏览器的信息。
- `Cookie`: 通常保存在浏览该域名时保存的一些数据，可以用于用户认证。
:::

:::
:::

---

### 响应头

同样在开发者工具中可以看到响应头，一些比较重要的是：

- `Status`: 极为重要！这里的代码反映了请求的状态。
  - `200`: 请求成功。
  - `404`: 找不到资源，通常是路径导致的错误。
  - `500`: 内部服务器错误，通常是请求参数或者数据错误。
- `Content-Type`: 响应体的格式。
- `Content-Encoding`: 响应体编码，通常是一些压缩数据的格式，例如 `gzip` 等，解压后可得到原始数据。

## Cookie

HTTP 协议有一大特点：“无状态”。任何两次 HTTP 请求和响应都是独立的，服务器不会保存任何与请求有关的信息。
但用户往往需要在不同页面之间跳转以完成一个工作，这种情况下就必然需要一些信息关联不同的页面。

- 用户在登录页进行登录，在其他页面访问一些个人数据。
- 用户在购物页选择要购买的商品，在购物车页面管理添加的商品，并在支付页进行支付。

Cookie 就是一种保存必要数据的方法。
每次发送请求时，Cookie 都会自动放在请求头中发送。
